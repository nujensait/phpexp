Вашему коду приходится работать с большим количеством объектов некой сложной библиотеки или фреймворка. Вы должны
самостоятельно инициализировать эти объекты, следить за правильным порядком зависимостей и так далее.

В результате бизнес-логика ваших классов тесно переплетается с деталями реализации сторонних классов. Такой код довольно
сложно понимать и поддерживать.

Фасад — это простой интерфейс для работы со сложной подсистемой, содержащей множество классов. Фасад может иметь
урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь, используя сложную подсистему напрямую.
Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные.

Фасад полезен, если вы используете какую-то сложную библиотеку со множеством подвижных частей, но вам нужна только
часть её возможностей.

К примеру, программа, заливающая видео котиков в социальные сети, может использовать профессиональную библиотеку сжатия
видео. Но все, что нужно клиентскому коду этой программы — простой метод encode(filename, format). Создав класс с таким
методом, вы реализуете свой первый фасад.

Когда вы звоните в магазин и делаете заказ по телефону, сотрудник службы поддержки является вашим фасадом ко всем
службам и отделам магазина. Он предоставляет вам упрощённый интерфейс к системе создания заказа, платёжной системе
и отделу доставки.

Применимость

Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.

Часто подсистемы усложняются по мере развития программы. Применение большинства паттернов приводит к появлению меньших
классов, но в бóльшем количестве. Такую подсистему проще повторно использовать, настраивая её каждый раз под конкретные
нужды, но вместе с тем, применять подсистему без настройки становится труднее. Фасад предлагает определённый вид системы
по умолчанию, устраивающий большинство клиентов.

Когда вы хотите разложить подсистему на отдельные слои.

Используйте фасады для определения точек входа на каждый уровень подсистемы. Если подсистемы зависят друг от друга, то
зависимость можно упростить, разрешив подсистемам обмениваться информацией только через фасады.

Например, возьмём ту же сложную систему видеоконвертации. Вы хотите разбить её на слои работы с аудио и видео. Для
каждой из этих частей можно попытаться создать фасад и заставить классы аудио и видео обработки общаться друг с другом
через эти фасады, а не напрямую.

Шаги реализации

1. Определите, можно ли создать более простой интерфейс, чем тот, который предоставляет сложная подсистема.
Вы на правильном пути, если этот интерфейс избавит клиента от необходимости знать о подробностях подсистемы.

2. Создайте класс фасада, реализующий этот интерфейс. Он должен переадресовывать вызовы клиента нужным объектам
подсистемы. Фасад должен будет позаботиться о том, чтобы правильно инициализировать объекты подсистемы.

3. Вы получите максимум пользы, если клиент будет работать только с фасадом. В этом случае изменения в подсистеме будут
затрагивать только код фасада, а клиентский код останется рабочим.

4. Если ответственность фасада начинает размываться, подумайте о введении дополнительных фасадов.


Думайте о Фасаде как о «адаптере-упрощателе» для некой сложной подсистемы. Фасад изолирует сложность в рамках одного
класса и позволяет остальному коду приложения использовать простой интерфейс.

В этом примере Фасад скрывает сложность API YouTube и библиотеки FFmpeg от клиентского кода. Вместо того, чтобы работать
с десятками классов, клиент использует простой метод Фасада.