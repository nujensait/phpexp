## Что это?

Задачки с live-coding интервью на должность бэкенд-разработчика php/golang в АвитоТех.

### Задача №1: сложение массивов

Мы хотим складывать очень большие числа, которые превышают емкость базовых типов, 
поэтому мы храним их в виде массива неотрицательных чисел.

Нужно написать функцию, которая примет на вход два таких массива, 
вычислит сумму чисел, представленных массивами, и вернет результат в виде такого же массива.

#### Пример

```
ввод

arr1 = [1, 2, 3] # число 123
arr2 = [4, 5, 6] # число 456

вывод

res = [5, 7, 9] # число 579 (допустим ответ с первым незначимым нулем [0, 5, 7, 9])
```

#### Решение
Вспомним курс школьной математики. 
Будем складывать два числа, наинчая с младших разрядов (т.е. с конца), 
с переносом остатка от сложения в следующий разряд.

#### Запуск
```
php array_sum.php
```

-----------------------

### Задача №2: самые популярные элементы массива

Дан массив целых чисел nums и целое число k.

Нужно написать функцию на PHP, которая вынимает из массива k наиболее часто встречающихся элементов.

#### Пример
```
ввод
nums = [1,1,1,2,2,3]
k = 2

вывод (в любом порядке)
[1, 2]
```

#### Решение #1 (не оптимальное)

Строим массив частот повторяемости элементов, сортируем его по убыванию (ф-ей arsort).
Берем первые N элементов из отсортированного массива.

(*) Это решение **не оптимально**, т.к. алг. сложность - O(N*log(n)) из-за функции сортировки:

Функция arsort в PHP сортирует массив по значению в обратном порядке (от большего к меньшему).
Алгоритмическая сложность функции arsort: O(N log N), где N - размер сортируемого массива.

*Как решить задачу со временем O(N)? Смотрим решение №2.*

Запуск:
```
php freq_nums.php
```

#### Решение #2 (оптимальное)

Здесь вместо сортировки строим хеш-массив вида:
```
[<частота> => <элементы>]
```
Т.о., пробегаясь по его элеметам (от старшего элемента вниз),
получим элементы исходного массива с максимальными частотами.

Запуск: 
```
php freq_nums2.php
```