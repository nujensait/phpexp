[English version](README.ENG.MD)

## Что это?

Задачки с live-coding интервью на должность бэкенд-разработчика php/golang в АвитоТех.

### Задача №1: сложение массивов

Мы хотим складывать очень большие числа, которые превышают емкость базовых типов, 
поэтому мы храним их в виде массива неотрицательных чисел.

Нужно написать функцию, которая примет на вход два таких массива, 
вычислит сумму чисел, представленных массивами, и вернет результат в виде такого же массива.

#### Пример

```
ввод

arr1 = [1, 2, 3] # число 123
arr2 = [4, 5, 6] # число 456

вывод

res = [5, 7, 9] # число 579 (допустим ответ с первым незначимым нулем [0, 5, 7, 9])
```

#### Решение
Вспомним курс школьной математики. 
Будем складывать два числа, наинчая с младших разрядов (т.е. с конца), 
с переносом остатка от сложения в следующий разряд.

#### Запуск
```
php array_sum.php
```

-----------------------

### Задача №2: самые популярные элементы массива

Дан массив целых чисел nums и целое число k.

Нужно написать функцию на PHP, которая вынимает из массива k наиболее часто встречающихся элементов.

#### Пример
```
ввод
nums = [1,1,1,2,2,3]
k = 2

вывод (в любом порядке)
[1, 2]
```

#### Решение #1 (не оптимальное)

Строим массив частот повторяемости элементов, сортируем его по убыванию (ф-ей arsort).
Берем первые N элементов из отсортированного массива.

(*) Это решение **не оптимально**, т.к. алг. сложность - O(N*log(n)) из-за функции сортировки:

Функция arsort в PHP сортирует массив по значению в обратном порядке (от большего к меньшему).
Алгоритмическая сложность функции arsort: O(N log N), где N - размер сортируемого массива.

*Как решить задачу со временем O(N)? Смотрим решение №2.*

Запуск:
```
php freq_nums.php
```

#### Решение #2 (оптимальное)

Здесь вместо сортировки строим хеш-массив вида:
```
[<частота> => <элементы>]
```
Т.о., пробегаясь по его элеметам (от старшего элемента вниз),
получим элементы исходного массива с максимальными частотами.

Запуск: 
```
php freq_nums2.php
```

-----------------------

### Задача №3 (секция Платформа): Добавление кэширования
Добавить кэширование в метод getByIds в файле (интерфейс для кеша указан), 
т.о. чтобы ИД кэшировались и обращение к API шло только если данных нет в кеше.

#### Исходный код
см. файл ``cache_task_src.php``

#### Решение
см. файл ``cache_task_solution.php``

-----------------------

### Задача №4 (секция Платформа): Чтение большого лога

В коде ниже написать тело метода numberOfErrors т.о., 
чтобы в нем считалось кол-во ошибок указанного  типа в лог-файле. 
Фишка в том, что файл м.б. большой (много Гб), и скрипт не должен падать 
из-за лимитов по памяти. 

(*) **Доп. вопрос:** как выдать результат спустя 100 микро-сек запуска ?
То есть если сервером задано ограничение на время запуска скрипта 
в ~100 мсек, и нельзя его превысить, и нужно выдать результат (кол-во посчитанных ошибок) - 
сколько успели посчитать за это время. 

#### Исходный код
см. файл ``read_log_src.php``

#### Решение
см. файл ``read_log_solution.php``
